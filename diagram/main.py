from fastapi import FastAPI, HTTPException, Body, Depends
from typing import List, Dict, Any, Optional
from uuid import UUID
from datetime import datetime
from sqlmodel import select, SQLModel # Added select
from sqlmodel.ext.asyncio.session import AsyncSession # Added AsyncSession

import json # For converting dict payload to bytes
from .models import UMLDiagramDB, CreateDiagramRequest, UpdateDiagramRequest, UMLDiagramResponse
from .database import get_async_session, init_db
from .storage import ensure_bucket_exists, upload_diagram_payload, get_diagram_payload, delete_diagram_payload, MINIO_BUCKET_NAME # Import storage functions

app = FastAPI()

# Remove MOCK_DB and DEFAULT_MOCK_OWNER_ID as we'll use the actual database
# MOCK_DB: Dict[UUID, UMLDiagramDB] = {}
DEFAULT_MOCK_OWNER_ID = UUID("00000000-0000-0000-0000-000000000000") # Still used for default owner

@app.on_event("startup")
async def on_startup():
    # This will create tables based on SQLModel metadata.
    # In a prod app, use Alembic for migrations.
    await init_db()
    await ensure_bucket_exists() # Ensure MinIO bucket is ready

@app.get("/")
async def root():
    return {"message": "Diagram Service"}

@app.get("/health")
async def health_check():
    return {"status": "ok"}

@app.get("/diagrams", response_model=List[UMLDiagramResponse])
async def get_diagrams(session: AsyncSession = Depends(get_async_session)):
    result = await session.execute(select(UMLDiagramDB))
    diagrams = result.scalars().all()
    return [UMLDiagramResponse.model_validate(db_item) for db_item in diagrams]

@app.post("/diagrams", response_model=UMLDiagramResponse, status_code=201)
async def create_diagram(diagram_data: CreateDiagramRequest = Body(...), session: AsyncSession = Depends(get_async_session)):
    # In a real scenario, payload would be uploaded to MinIO and payload_url would be its path
    # For now, we'll generate a mock URL. The ID for the diagram is generated by UMLDiagramDB model default.

    # The id is generated by default_factory in the model if not provided
    # created_at and updated_at are also set by default_factory
    db_diagram = UMLDiagramDB(
        name=diagram_data.name,
        owner_id=diagram_data.owner_id or DEFAULT_MOCK_OWNER_ID,
        # payload_url will be updated after actual MinIO upload
        payload_url=f"s3://mock-bucket/placeholder.json" # Initial placeholder
    )
    # Generate a payload URL based on the (soon to be) generated ID
    # This is a bit of a chicken-and-egg if ID is DB-generated and needed for URL before commit.
    # The id is generated by default_factory in the model if not provided
    # created_at and updated_at are also set by default_factory

    # 1. Prepare data for MinIO (payload) and DB (metadata)
    payload_bytes = json.dumps(diagram_data.payload).encode('utf-8')
    # Generate a unique object name, e.g., using UUID. This will be part of the payload_url.
    # It's better to use the diagram's future ID if possible, but that might require two steps
    # or a predefined ID. Let's use a new UUID for the object name for simplicity first.
    object_name = f"{uuid.uuid4()}.json"

    try:
        # 2. Upload to MinIO first
        # If this fails, we don't create a DB record
        payload_s3_url = await upload_diagram_payload(object_name, payload_bytes)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to upload diagram payload to MinIO: {str(e)}")

    # 3. Create DB record with the URL from MinIO
    db_diagram = UMLDiagramDB(
        name=diagram_data.name,
        owner_id=diagram_data.owner_id or DEFAULT_MOCK_OWNER_ID,
        payload_url=payload_s3_url # Use the actual URL from MinIO
    )

    session.add(db_diagram)
    try:
        await session.commit()
        await session.refresh(db_diagram)
    except Exception as e:
        # If DB commit fails, we should ideally try to delete the object from MinIO (rollback)
        try:
            await delete_diagram_payload(object_name)
        except Exception as del_e:
            # Log the deletion error, but the primary error is the DB commit failure
            print(f"Failed to delete MinIO object {object_name} after DB commit failure: {del_e}")
        raise HTTPException(status_code=500, detail=f"Failed to save diagram metadata to database: {str(e)}")

    return UMLDiagramResponse.model_validate(db_diagram)

@app.get("/diagrams/{id}", response_model=UMLDiagramResponse) # We also need to return the payload for GET {id}
async def get_diagram(id: UUID, session: AsyncSession = Depends(get_async_session)):
    db_diagram = await session.get(UMLDiagramDB, id)
    if not db_diagram:
        raise HTTPException(status_code=404, detail="Diagram not found")

    # Construct the object name from payload_url
    # Assuming payload_url is like "s3://bucket_name/object_name"
    try:
        # A more robust way to parse S3 URI might be needed if format varies
        if "://" in db_diagram.payload_url:
            object_name = db_diagram.payload_url.split("/")[-1]
        else: # Or if it's just the object name
            object_name = db_diagram.payload_url

        payload_bytes = await get_diagram_payload(object_name)
        payload_dict = json.loads(payload_bytes.decode('utf-8'))
    except FileNotFoundError:
        # If payload is not found in MinIO, we might still return metadata or raise error
        # For now, let's return metadata with payload as None and log an error
        print(f"Payload not found in MinIO for diagram {id}, object {object_name}")
        payload_dict = None
    except Exception as e:
        # Other errors during payload fetch
        print(f"Error fetching payload for diagram {id} from MinIO: {str(e)}")
        # Depending on requirements, could raise 500 or return metadata with None payload
        raise HTTPException(status_code=500, detail=f"Failed to retrieve diagram payload: {str(e)}")

    response_data = UMLDiagramResponse.model_validate(db_diagram).model_dump()
    response_data["payload"] = payload_dict

    return UMLDiagramResponse(**response_data)

@app.put("/diagrams/{id}", response_model=UMLDiagramResponse)
async def update_diagram(id: UUID, diagram_data: UpdateDiagramRequest = Body(...), session: AsyncSession = Depends(get_async_session)):
    db_diagram = await session.get(UMLDiagramDB, id)
    if not db_diagram:
        raise HTTPException(status_code=404, detail="Diagram not found")

    update_values = diagram_data.model_dump(exclude_unset=True)

    if "name" in update_values and update_values["name"] is not None:
        db_diagram.name = update_values["name"]

    # Handling payload update:
    # If payload is part of the update, it implies the content in MinIO should be updated.
    # The payload_url might not change unless the naming convention of objects in MinIO changes
    # (e.g., includes a version hash). For now, we assume payload_url remains the same.
    if "payload" in update_values and update_values["payload"] is not None:
        try:
            # Extract object name from URL
            if "://" in db_diagram.payload_url: # type: ignore
                object_name = db_diagram.payload_url.split("/")[-1] # type: ignore
            else:
                object_name = db_diagram.payload_url # type: ignore

            payload_bytes = json.dumps(update_values["payload"]).encode('utf-8')
            await upload_diagram_payload(object_name, payload_bytes) # Overwrites existing object
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to update diagram payload in MinIO: {str(e)}")

    db_diagram.updated_at = datetime.utcnow() # Manually update timestamp

    session.add(db_diagram) # type: ignore
    await session.commit()
    await session.refresh(db_diagram) # type: ignore

    # Similar to GET, fetch the payload to include in the response
    response_with_payload = UMLDiagramResponse.model_validate(db_diagram).model_dump()
    if "payload" in update_values and update_values["payload"] is not None:
         response_with_payload["payload"] = update_values["payload"] # Use the payload we just uploaded
    elif db_diagram.payload_url: # type: ignore
        try:
            if "://" in db_diagram.payload_url: # type: ignore
                object_name = db_diagram.payload_url.split("/")[-1] # type: ignore
            else:
                object_name = db_diagram.payload_url # type: ignore
            payload_bytes = await get_diagram_payload(object_name)
            response_with_payload["payload"] = json.loads(payload_bytes.decode('utf-8'))
        except Exception as e:
            print(f"Failed to fetch payload for updated diagram {id}: {e}")
            # Payload will remain None in response if fetch fails

    return UMLDiagramResponse(**response_with_payload)

@app.delete("/diagrams/{id}", response_model=Dict[str, bool])
async def delete_diagram(id: UUID, session: AsyncSession = Depends(get_async_session)):
    db_diagram = await session.get(UMLDiagramDB, id)
    if not db_diagram:
        raise HTTPException(status_code=404, detail="Diagram not found")

    try:
        if db_diagram.payload_url:
            if "://" in db_diagram.payload_url:
                object_name = db_diagram.payload_url.split("/")[-1]
            else:
                object_name = db_diagram.payload_url
            await delete_diagram_payload(object_name)
    except Exception as e:
        # Log error but proceed to delete DB record, or handle more gracefully
        print(f"Failed to delete payload from MinIO for diagram {id}: {str(e)}. Proceeding with DB deletion.")

    await session.delete(db_diagram)
    await session.commit()
    return {"success": True}

import uuid # Added for placeholder payload_url generation
